\chapter{Аналитическая часть}

\section{Постановка задачи}
Необходимо реализовать программный продукт, предоставляющий визуализацию системы космических объектов.
Также необходимо осуществить выбор метода решения. Пользователь должен иметь возможность запустить и остановить визуализируемую систему. Полученное изображение должно четко показывать работу данной системы.

\section {Описание предметной области}
Компьютерная графика играет важную роль в IT сфере. Она решает множество проблем, акутальных на данный момент.
Разработка алгоритмов визуализации трехмерных объектов является обязательной задачей компьютерной графики.
К примеру, визуализацию различных
систем и процессов для демонстрации определенных явлений.


\section {Алгоритмы удаления невидимых линий}

\subsection{Алгоритм Робертса}

Алгоритм Робертса позволяет произвести удаление невидимых линий при помощи математических вычислений. Алгоритм работает в объектном пространстве с выпуклыми телами. Если имеются невыпуклые тела, необходимо сначала разбить их на выпуклые.

Сначала удаляются ребра и грани, экранируемые самим объектом, а затем линии, экранируемые другими объектами сцены.

К достоинствам алгоритма можно отнести точность и быстроту работы математических методов.

Недостатком метода является то, что вычислительная сложность алгоритма растет как квадрат числа объектов сцены.

Существуют модификации данного алгоритма. При использовании приоритетной сортировки вдоль оси z и простых габаритных или минимаксных тестов, вычислительная сложность линейно зависит от количества объектов. Однако реализация модифицированных алгоритмов достаточно сложна.


\subsection{Алгоритм Варнока}

Алгоритм Варнока работает в пространстве изображений. В пространстве изображений анализируется информация, содержащаяся в окне. Если окно не перекрывается ни одним многоугольником, оно считается пустым. Если окно содержит пустые области и области, покрываемые многоугольниками, то окно разбивается на подокна до тех пор, пока остаются области, содержащие не один многоугольник. Если результирующее окно имеет размер один пиксел, но оно перекрывается несколькими многоугольниками, необходимо сравнить глубину этих многоугольников и высветить пиксел цветом ближайшего к наблюдателю многоугольника.
\begin{figure}[ht!]
	\centering{
		\includegraphics[width=0.5\textwidth]{warnock_algorithm_example2.png}
		\caption{Пример разбиения Алгоритмом Варнока}
		\label{ref:Warn}}
\end{figure}


Алгоритм достаточно прост с точки зрения понимания, однако может потребоваться большое количество разбиений, соответственно потребуется много времени на анализ и отображение содержимого всего окна.

\subsection{Алгоритм Вейлера-Азертона}

Алгоритм Вейлера-Азертона предназначен для минимизации количества разбиений в алгоритме представленном выше (Алгоритме Варнока) путем разбиения окна вдоль границ многоугольника. Основой служит алгоритм Вейлера-Азертона, который используется для отсечения многоугольников.

Если многоугольники пересекаются, то для корректной работы данного алгоритма нужно плоскость одного разбить другим на две части. Эффективность алгоритма Вейлера-Азертона, как и алгоритма Варнока, зависит от эффективности разбиений. В дальнейшем этот алгоритм был распространен на сплайновые поверхности. К достоинствам алгоритма можно отнести скорость работы, учет когерентности изображения. Недостатками алгоритма является сложность реализации, а также невозможность передачи зеркальных эффектов и преломления света.
\subsection{Алгоритм Z буфера}


\begin{figure}[ht!]
	\centering{
		\includegraphics[width=0.5\textwidth]{z_buffer.png}
		\caption{Пример работы алгоритма Z буфера}
		\label{ref:Warnock}}
\end{figure}

Алгоритм Z буфера решает задачу в пространстве изображений. Сцены могут быть произвольной сложности, а поскольку размеры изображения ограничены размером экрана дисплея, то трудоемкость алгоритма зависит линейно от числа рассматриваемых поверхностей. Элементы сцены заносятся в буфер кадра в произвольном порядке, поэтому в данном алгоритме не тратится время на выполнение сортировок.

Буфер кадра (регенерации) используется для заполнения атрибутов (интенсивности) каждого пикселя в пространстве изображения. Для него требуется буфер регенерации, в котором запоминаются значения яркости, а также Z буфер (буфер глубины), куда можно помещать информацию о координате z для каждого пикселя.

Для начала нужно подготовить буферы. Для этого в Z буфер заносятся максимально возможные значения z, а буфер кадра заполняется значениями пикселя, который описывает фон. Также нужно каждый многоугольник преобразовать в растровую форму и записать в буфер кадра. Сам процесс работы заключается в сравнении глубины каждого нового пикселя, который нужно занести в буфер кадра, с глубиной того пикселя, который уже занесен в Z буфер. В зависимости от сравнения принимается решение, нужно ли заносить новый пиксель в буфер кадра и, если нужно, также корректируется Z буфер (в него нужно занести глубину нового пикселя).

К достоинствам алгоритма, использующего z-буффер можно отнести простоту реализации, а также отсутствие предварительной сортировки элементов сцены. Недостатками алгоритма являются трудоёмкость реализации эффектов прозрачности, а также перерасход по памяти - алгоритм предполагает хранение двух двумерных массивов, размер которых увеличивается с увеличением размеров изображения.




\subsection{Выбор алгоритма удаления невидимых граней}
При реализации программного продукта использован алгоритм Z-буфера. Этот алгоритм позволяет строить сцены любой сложности, а также достаточно быстро работает за счет отсутствия сложных вычислений. 
Так как на сегодняшний день размер оперативной памяти достаточно велик, использование большого объема памяти не является существенным недостатком применения данного алгоритма в программном продукте.
Для увеличения скорости отрисовки каждого объекта треугольники, составляющие объект, отсортированы по оси z по возрастанию (ось Z направлена от наблюдателя).




\section{Алгоритмы закраски}

\subsection{Закраска методом Гуро}

При данном виде закраски интерполируется значение интенсивности, что позволяет получить сглаженное изображение. Данный алгоритм закраски проще, чем алгоритм закраски Фонга. Недостатками метода Гуро является появление полос Маха (алгоритм не обеспечивает непрерывность изменения интенсивности), а также то, что при линейной интерполяции значение интенсивности на некоторых участках может быть получится равной, и поверхность на этих участках будет выглядеть плоской.
Метод основан на идее закрашивания грани не одним цветом, а плавно изменяющимися оттенками. Для вычисления оттенка, интерполируются цвета примыкающих граней.
Для реализации метода Гуро необходимо вычислить нормали к каждой грани. Затем, необходимо определить усредненные нормали в вершинах. Для этого усредняются значения нормалей примыкающих граней



\begin{figure}[ht!]
	\centering{
		\includegraphics[width=0.5\textwidth]{guro1.jpg}
		\caption{}
		\label{ref:Warnock}}
\end{figure}

Далее, на основе усредненных нормалей вычисляются интенсивности в вершинах. Грань закрашивается цветом, полученным на основе интерполяции интенсивности в вершинах.


\begin{figure}[ht!]
	\centering{
		\includegraphics[width=0.5\textwidth]{guro2.png}
		\caption{}
		\label{ref:Warnock}}
\end{figure}




\subsection{Закраска Фонга}



Закраска Фонга сложнее в реализации, однако она позволяет устранить недостатки закраски методом Гуро за счет того, что интерполируются нормали к полигонам, а не значения интенсивности. Это позволяет уменьшить количество полос Маха. Более реалистично выглядят зеркальные блики.


Для реализации метода Фонга необходимо проделать следующие операции. Сначала, определяются нормали к граням. Затем, по нормалям к граням определяются усредненные нормали в вершинах. Далее, с помощью интерполяции вычисляются интерполированные векторы нормали в каждой точке грани. На основе направления нормали определяется интенсивность каждой точки.






\subsection{Выбор алгоритма закраски}
В разрабатываемом программном продукте использована закраска Гуро, так как она требует меньшего количества вычислений, что приведет к увеличению быстродействия программы. К тому же, как показал Дафф, эффект полос Маха проявляется сильнее для сфер при использовании закраски Фонга. Учитывая, что сфера является одним из наиболее часто используемых объектов сцены, целесообразно учесть это замечание и прибегнуть к закраске Гуро. Также, моделируемые объекты имеют матовую структуру, а превосходство метода Фонга над методом Гуро наиболее ярко проявляется при наличии зеркальных бликов матовых поверхностей.




\section {Модель освещения}

\subsection{Локальная модель освещения}
Локальная модель учитывает освещение точечных источников, непосредственно освещающих сцену. Многократное отражение и преломление лучей от различных объектов сцены не учитывается.

\subsection{Глобальная модель освещения}
В глобальной модели освещения отслеживается весь путь луча до тех пор, пока он не покинет сцену или переносимая им энергия не станет достаточно малой, чтобы не учитывать ее. Для этого вводится ограничение количество отражений, поскольку при каждом отражении теряется часть энергии луча.
Глобальная модель освещения является более точной, так как точнее передает то, как распространяется свет в реальности. Однако при работе с матовыми объектами, локальная модель освещения позволяет достаточно точно визуализировать рассматриваемые объекты.

\subsection{Выбор модели осещения}
В разрабатываемом продукте используется локальная модель освещения, так как для реализации глобальной модели необходима трассировка лучей, что увеличит количество вычислений и время выполнения программы. К тому же, моделируемые объекты будут матовыми, и при первом отражении энергия луча будет сильно уменьшаться.





\section {Преобразования}

\subsection {Перенос}

Для переноса потребуется два параметра: dx - смещение по оси абсцисс и dy - смещение по оси ординат.

\begin{equation}
	{\begin{cases}
			x_1 = x + dx \\
			y_1 = y + dy \\
		\end{cases}}
\end{equation}

Матрица переноса в двухмерном пространстве:

\begin{equation}
	Mmove = \left(
	\begin{array}{cccc}
			1  & 0  & 0 \\
			0  & 1  & 0 \\
			dx & dy & 1 \\
		\end{array}
	\right)
\end{equation}

Матрица переноса в трехмерном пространстве:

\begin{equation}
	Mmove = \left(
	\begin{array}{cccc}
			1  & 0  & 0  & 0 \\
			0  & 1  & 0  & 0 \\
			0  & 0  & 1  & 0 \\
			dx & dy & dz & 1 \\
		\end{array}
	\right)
\end{equation}

\subsection {Масштабирование}

Масштабирование - изменение размера. Задается коэффициентами масштабирования kx, ky и центром масштабирования xm, ym. Иллюстрация представлена на рисунке \ref{fig:ref1} \\
\begin{figure}[ht!]
	\centering{
		\includegraphics[width=0.6\textwidth]{move.jpg}
		\caption{Перемещение точки}
		\label{fig:ref1}}
\end{figure}
\\
При kx = ky масштабирование однородное.\\
При kx $\neq$ ky масштабирование неоднородное.\\
Отражение относительно OY: kx = -1, ky = 1.\\
Отражение относительно OX: kx = 1, ky = -1.\\
Отражение относительно начала координат: kx = -1, ky = -1.\\
Если коэффициент масштабирования больше 1, то изображение удаляется от центра и увеличивается.\\
Если коэффициент масштабирование меньше 1, то изображение приближается к центру и уменьшается.\\

Из Рис. \ref{fig:ref1} получаем:

\begin{equation}
	{\begin{cases}
			x_1 - x_m = kx(x - x_m) \\
			y_1 - y_m = ky(y - y_m)
			\label{eq:ref4}
		\end{cases}}
\end{equation}

Упростим (\ref{eq:ref4}) и получим:

\begin{equation}
	{\begin{cases}
			x_1 = kx * x + (1 - kx) * x_m \\
			y_1 = ky * y + (1 - ky) * y_m \\
		\end{cases}}
\end{equation}

Матрица масштабирования в двухмерном пространстве:

\begin{equation}
	Mscale = \left(
	\begin{array}{cccc}
			kx & 0  & 0 \\
			0  & ky & 0 \\
			0  & 0  & 1 \\
		\end{array}
	\right)
\end{equation}

Матрица масштабирования в трехмерном пространстве (добавляется коэффициент масштабирования: kz):

\begin{equation}
	Mscale = \left(
	\begin{array}{cccc}
			kx & 0  & 0  & 0 \\
			0  & ky & 0  & 0 \\
			0  & 0  & kz & 0 \\
			0  & 0  & 0  & 1 \\
		\end{array}
	\right)
\end{equation}

\subsection {Поворот}

Для поворота потребуется угол  $\theta$ и центр C(xc, yc) (рис. \ref{fig:ref2}).
\begin{figure}[ht!]
	\centering{
		\includegraphics[width=0.6\textwidth]{rotate.jpg}
		\caption{Поворот точки}
		\label{fig:ref2}}
\end{figure}

Поворот против часовой стрелки:
\begin{multline}
	\\
	x_1 = x_c + R*cos(180^{\circ}-(\varphi +  \theta)) = \\
	x_c - R*cos(\varphi)*cos(\theta) + R*sin(\varphi)*sin(\theta) = \\
	x_c - (x_c - x)cos(\theta) + (y - y_c)sin(\theta) = \\
	x_c + (x - x_c)cos(\theta) + (y - y_c)sin(\theta) \\
\end{multline}

\begin{multline}
	\\
	y_1 = y_c + R*sin(180^{\circ}-(\varphi +  \theta)) = \\
	y_c + R*sin(\varphi)*cos(\theta) + R*cos(\varphi)*sin(\theta) = \\
	y_c + (y - y_c)cos(\theta) + (x_c- x)sin(\theta) = \\
	y_c + (y - y_c)cos(\theta) - (x - x_c)sin(\theta) \\
\end{multline}

Матрица поворота против часовой стрелки в двухмерном пространстве:

\begin{equation}
	Mrotate = \left(
	\begin{array}{cccc}
			cos(\theta) & -sin(\theta) & 0 \\
			sin(\theta) & cos(\theta)  & 0 \\
			0           & 0            & 1 \\
		\end{array}
	\right)
\end{equation}

Матрица поворота в трехмерном пространстве вокруг оси Z :

\begin{equation}
	Mrotate = \left(
	\begin{array}{cccc}
			cos(\theta) & -sin(\theta) & 0 & 0 \\
			sin(\theta) & cos(\theta)  & 0 & 0 \\
			0           & 0            & 1 & 0 \\
			0           & 0            & 0 & 1 \\
		\end{array}
	\right)
\end{equation}

\newpage

\section {Вывод}

Оценив все изложенные выше алгоритмы для реализации программного обеспечения, можно сделать вывод, что для данной работы подходит следующий набор алгоритмов: закраска Гуро совместно с z-буфером, локальная модель освещения. 




